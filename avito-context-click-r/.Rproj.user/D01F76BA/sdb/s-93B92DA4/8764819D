{
    "contents" : "options(warn=-1)\nsuppressMessages(library(\"data.table\"))\nsuppressMessages(library(\"compiler\"))\n\nenableJIT(3) \nsetCompilerOptions(suppressUndefined = T)\noptions(stringsAsFactors = FALSE)\noptions(max.print = 500)\noptions(scipen=999)\n\npath.wd <- getwd()\nSys.setenv(\"R_LOCAL_CACHE\"=\"../data/output-r/.R_Cache\")\n\n`%ni%` <- Negate(`%in%`)\n\nsuppressMessages(library(\"ffbase\"))\nsuppressMessages(library(\"SOAR\"))\nsuppressMessages(library(\"SparseM\"))\nsuppressMessages(library(\"Matrix\"))\nsuppressMessages(library(\"matrixStats\"))\n\nsuppressMessages(library(\"Rcpp\"))\nsuppressMessages(library(\"xgboost\"))\n\nsuppressMessages(library(infotheo))\nsuppressMessages(library(tm))\n\nsourceCpp(\"_fn.base.cpp\")\n\nall.noexport <- c(Objects(), \"fn_opt_gm\", \"fn_opt_am\")\n\nsearch.info.file <- \"SearchInfo.tsv\"\ntrain.file <- \"trainSearchStream.tsv\"\ntest.file <- \"testSearchStream.tsv\"\nuser.info.file <- \"UserInfo.tsv\"\ncategory.file <- \"Category.tsv\"\nphone.request.stream.file <- \"PhoneRequestsStream.tsv\"\nvisit.stream.file <- \"VisitsStream.tsv\"\nads.info.file <- \"AdsInfo.tsv\"\n\n#############################################################\n# tic toc\n#############################################################\ntic <- function(gcFirst = TRUE, type=c(\"elapsed\", \"user.self\", \"sys.self\")) {\n  type <- match.arg(type)\n  assign(\".type\", type, envir=baseenv())\n  if(gcFirst) gc(FALSE)\n  tic <- proc.time()[type]         \n  assign(\".tic\", tic, envir=baseenv())\n  invisible(tic)\n}\n\ntoc <- function() {\n  type <- get(\".type\", envir=baseenv())\n  toc <- proc.time()[type]\n  tic <- get(\".tic\", envir=baseenv())\n  print(toc - tic)\n  invisible(toc)\n}\n\n##############################################################\n## Registers parallel workers\n##############################################################\nfn.register.wk <- function(n.proc = NULL, seed=5478557) {\n  if (file.exists(fn.in.file(\"cluster.csv\"))) {\n    cluster.conf <- read.csv(fn.in.file(\"cluster.csv\"), \n                             stringsAsFactors = F,\n                             comment.char = \"#\")\n    n.proc <- NULL\n    for (i in 1:nrow(cluster.conf)) {\n      n.proc <- c(n.proc, \n                  rep(cluster.conf$host[i], \n                      cluster.conf$cores[i]))\n    }\n  }\n  if (is.null(n.proc)) {\n    n.proc = as.integer(Sys.getenv(\"NUMBER_OF_PROCESSORS\"))\n    if (is.na(n.proc)) {\n      suppressMessages(library(parallel))\n      n.proc <-detectCores()\n    }\n  }\n  workers <- mget(\".pworkers\", envir=baseenv(), ifnotfound=list(NULL));\n  if (!exists(\".pworkers\", envir=baseenv()) || length(workers$.pworkers) == 0) {\n    \n    suppressMessages(library(doSNOW))\n    suppressMessages(library(foreach))\n    workers<-suppressMessages(makeSOCKcluster(n.proc))\n    suppressMessages(registerDoSNOW(workers))\n    suppressMessages(clusterSetupRNG(workers, seed=seed))\n    assign(\".pworkers\", workers, envir=baseenv())\n    \n    tic()\n    cat(\"Started\", n.proc, \"worker(s): \", \n        format(Sys.time(), format = \"%Y-%m-%d %H:%M:%S\"), \"\\n\")\n  }\n  invisible(workers);\n}\n\n##############################################################\n## Kill parallel workers\n##############################################################\nfn.kill.wk <- function() {\n  suppressMessages(library(\"doSNOW\"))\n  suppressMessages(library(\"foreach\"))\n  workers <- mget(\".pworkers\", envir=baseenv(), ifnotfound=list(NULL));\n  if (exists(\".pworkers\", envir=baseenv()) && length(workers$.pworkers) != 0) {\n    suppressMessages(stopCluster(workers$.pworkers));\n    assign(\".pworkers\", NULL, envir=baseenv());\n    cat(\"Workers finish time: \", format(Sys.time(), \n                                        format = \"%Y-%m-%d %H:%M:%S\"), \"\\n\")\n    toc()\n  }\n  invisible(workers);\n}\n\n##############################################################\n## init worker setting work dir and doing path redirect\n##############################################################\nfn.init.worker <- function(log = NULL, add.date = F) {\n  \n  source(\"_fn.base.R\")\n  setwd(path.wd)\n  \n  if (!is.null(log)) {\n    date.str <- format(Sys.time(), format = \"%Y-%m-%d_%H-%M-%S\")\n    \n    if (is.list(log) && \"logname\" %in% names(log)) {\n      log <- log[[\"logname\"]]\n    }\n  \n    \n    if (add.date) {\n      output.file <- fn.log.file(paste(log, \"___\",date.str,\n                                       \".log\", sep=\"\"))\n    } else {\n      output.file <- fn.log.file(paste(log,\".log\", sep=\"\"))\n    }\n    dir.create(dirname(output.file), showWarnings = F, recursive = T)\n    output.file <- file(output.file, open = \"wt\")\n    sink(output.file)\n    sink(output.file, type = \"message\")\n    \n    cat(\"Start:\", date.str, \"\\n\")\n  }\n  \n  tic()\n}\n\n##############################################################\n## clean worker resources\n##############################################################\nfn.clean.worker <- function() {\n  gc()\n  \n  try(toc(), silent=T)\n  suppressWarnings(sink())\n  suppressWarnings(sink(type = \"message\"))\n  \n  invisible(NULL)\n}\n\n##############################################################\n## wait clean\n##############################################################\nfn.gc.wait <- function() {\n  invisible(gc())\n  Sys.sleep(1)\n  invisible(gc())\n}\n\n#############################################################\n# log file path\n#############################################################\nfn.base.dir <- function(extra) {\n  paste0(path.wd, \"/../data/\", extra)\n}\n\n#############################################################\n# log file path\n#############################################################\nfn.log.file <- function(name) {\n  fn.base.dir(paste0(\"log/\", name))\n}\n\n#############################################################\n# input file path\n#############################################################\nfn.in.file <- function(name) {\n  fn.base.dir(paste0(\"input/\", name))\n}\n\n#############################################################\n# R output file path\n#############################################################\nfn.out.file <- function(name) {\n  fn.base.dir(paste0(\"output-r/\", name))\n}\n\n#############################################################\n# python output file path\n#############################################################\nfn.py.file <- function(name) {\n  fn.base.dir(paste0(\"output-py/\", name))\n}\n\n#############################################################\n# libfm output file path\n#############################################################\nfn.libffm.file <- function(name) {\n  fn.base.dir(paste0(\"output-libffm/\", name))\n}\n\n#############################################################\n# dropbox file path\n#############################################################\nfn.dropbox.file <- function(name) {\n  fn.base.dir(paste0(\"dropbox/\", name))\n}\n\n#############################################################\n# matlab file path\n#############################################################\nfn.ml.file <- function(name) {\n  fn.base.dir(paste0(\"output-ml/\", name))\n}\n\n#############################################################\n# ranklib\n#############################################################\nfn.ranklib.file <- function(name) {\n  fn.base.dir(paste0(\"output-ranklib/\", name))\n}\n\n#############################################################\n# rdata files\n#############################################################\nfn.rdata.file <- function(name) {\n  fn.base.dir(paste0(\"rdata/\", name))\n}\n\n#############################################################\n# libsvm files\n#############################################################\nfn.libsvm.file <- function(name) {\n  fn.base.dir(paste0(\"libsvm/\", name))\n}\n\n#############################################################\n# submission file path\n#############################################################\nfn.submission.file <- function(name, suffix=\".csv\") {\n  fn.base.dir(paste0(\"submission/\", name, suffix))\n}\n\n#############################################################\n# data file path\n#############################################################\nfn.data.file <- function(name) {\n  fn.out.file(name)\n}\n\n#############################################################\n# save data file\n#############################################################\nfn.save.data <- function(dt.name, envir = parent.frame()) {\n  save(list = dt.name, \n       file = fn.data.file(paste0(dt.name, \".RData\")), envir = envir)\n}\n\n#############################################################\n# load saved file\n#############################################################\nfn.load.data <- function(dt.name, envir = parent.frame()) {\n  load(fn.data.file(paste0(dt.name, \".RData\")), envir = envir)\n}\n\n#############################################################\n# round predictions\n#############################################################\nfn.round.pred <- function(pred) {\n  round(pred, digits=6)\n}\n\n#############################################################\n# bounded log loss\n#############################################################\nfn.log.loss <- function(actual, pred) {\n  suppressMessages(library(\"Metrics\"))\n  ix <- !is.na(actual)\n  if (!any(ix)) {\n    return (NA_real_)\n  }\n  pred <- pmin(1-1e-15, pmax(1e-15, pred[ix]))\n  actual <- actual[ix]\n  return (logLoss(actual, pred))\n}\n\n#############################################################\n# error evaluation\n#############################################################\nfn.print.err <- function(data.pred, do.print = T, scale=1.0) { \n  \n  data.pred <- merge(data.pred[, list(ID, Pred)], \n                     data.all.out.small[, list(ID, IsClick)],\n                     by=\"ID\")\n  data.pred.ix <- !is.na(data.pred$IsClick)\n  data.pred[, Pred := fn.round.pred(Pred)*scale]\n\n  df <- data.frame(Size = nrow(data.pred))\n  if (sum(data.pred.ix) == 0) {\n    df[[\"Avg\"]] = mean(data.pred$Pred)\n  } else {\n    df[[\"Size\"]] = sum(data.pred.ix)\n    df[[\"Loss\"]] <- round(fn.log.loss(data.pred[data.pred.ix]$IsClick,\n                                      data.pred[data.pred.ix]$Pred), \n                          digits=5)\n  }\n  \n  if (do.print) {\n    print(df)\n  }\n  \n  invisible(df)\n}\n# debug(fn.print.err)\n\n\n#############################################################\n# gets train type\n#############################################################\nfn.lr.tr.type <- function(test.type) {\n  tr.type <- c(\"hist\")\n  if (test.type %in% c(\"val\", \"test\")) {\n    tr.type <- c(tr.type, \"tr\")\n  }\n  if (test.type %in% \"test\") {\n    tr.type <- c(tr.type, \"val\")\n  }\n  return(tr.type)\n}\n\n#############################################################\n# gets train type\n#############################################################\nfn.tree.tr.type <- function(test.type) {\n  if (test.type == \"test\") {\n    return (\"val\")\n  } else {\n    return (\"tr\")\n  }\n}\n\n#############################################################\n# gets train type\n#############################################################\nfn.l2.tr.type <- function(test.type) {\n  if (test.type == \"tr\") {\n    return (\"val\")\n  }\n  if (test.type == \"val\") {\n    return (\"tr\")\n  }\n  if (test.type == \"test\") {\n    return (c(\"tr\", \"val\"))\n  }\n}\n\n#############################################################\n# load libfm predictions\n#############################################################\nfn.load.libfm.pred <- function(data.fold, iters=1) {\n  data.pred <- data.table(ID=data.fold$test.ids, Pred=0)\n  for (it in 1:iters) {\n    data.pred[, Pred := Pred + \n                fread(paste(data.fold$test.pred.file, it, sep=\".\"), \n                      header=F)$V1/iters]\n  }\n  data.pred\n}\n\n#############################################################\n# creates data.fold for models\n#############################################################\nfn.create.data.fold <- function(model.name, model.type) {\n  data.fold <- list()\n  data.fold$basename <- model.name\n  data.fold$model.type <- model.type\n  data.fold$name <- paste0(data.fold$basename, \"_\", model.type)\n  data.fold$logname <- paste(data.fold$basename, data.fold$name, sep=\"/\")\n  data.fold$fname <- fn.out.file(paste0(data.fold$basename, \"/\", \n                                        data.fold$name, \".RData\"))\n  data.fold\n}\n\n\nfn.load.data.fold <- function(model.name, model.type, envir=parent.frame()) {\n  load(fn.out.file(paste0(model.name, \"/\", model.name,\n                          \"_\", model.type, \".RData\")),\n       envir=envir)\n}\n\nfn.file.data.fold <- function(data.fold, suffix) {\n  paste0(data.fold$writedir, \"/data.\", data.fold$model.type, \".\", suffix)\n}\n\nfn.init.fold.worker <- function(model.name, model.type, envir=parent.frame(),\n                                no.log=F) {\n  source(\"_fn.base.R\")\n  fn.load.data.fold(model.name = model.name, model.type = model.type,\n                    envir = envir)\n  assign('data.fold', data.fold, envir=envir)\n  if (no.log) {\n    fn.init.worker()\n  } else {\n    fn.init.worker(data.fold)\n  }\n  invisible(data.fold)\n}\n\nfn.init.new.fold.worker <- function(model.name, model.type, \n                                    envir=parent.frame(), ...) {\n  source(\"_fn.base.R\")\n  data.fold <- fn.create.data.fold(model.name, model.type)\n  assign('data.fold', data.fold, envir=envir)\n  fn.init.worker(data.fold, ...)\n  invisible(data.fold)\n}\n\n#############################################################\n# saves data from models for later inspection\n#############################################################\nfn.save.data.fold <- function(data.fold) {\n  dir.create(dirname(data.fold$fname), showWarnings = F, recursive = T)\n  save(data.fold, file=data.fold$fname)\n}\n\n\n#############################################################\n# copies data from one model to another\n#############################################################\nfn.copy.data.fold <- function(from, to) {\n  \n  for (test.type in c(\"tr\", \"val\", \"test\")) {\n    fn.load.data.fold(from, test.type)\n    for (nam in names(data.fold)) {\n      if (is.character(data.fold[[nam]])) {\n        data.fold[[nam]] <- gsub(from, to, data.fold[[nam]], fixed=T)\n      }\n    }\n    fn.save.data.fold(data.fold)\n  }\n  \n}\n\n##################################################\n# expand factors\n##################################################\nfn.expand.factors <- function(data.df) {\n  data.frame(model.matrix( ~ . - 1, data=data.df))\n}\n\n##############################################################\n## get with default value\n##############################################################\nfn.get <- function(var.name, def.val = NULL) {\n  if ( exists(var.name)) {\n    return(get(var.name))\n  } else {\n    return(def.val)\n  }\n}\n\n#############################################################\n# print rf importance\n#############################################################\nfn.rf.print.imp <- function(rf) {\n  imp <- try(data.frame(\n    importance=rf$importance[order(-rf$importance[,1]),]), silent = T)\n  imp$importance <- imp$importance/sum(imp$importance)*100\n  print(imp)\n  imp\n}\n\n#############################################################\n# write submission\n#############################################################\nfn.write.submission <- function(data.pred, file.name, mean.adj=F) { \n  tic()\n  data.sub <- merge(\n    data.pred[ID > 0, list(ID, Pred)],\n    data.all.out.small[, list(ID, Position)],\n    by=\"ID\")\n  data.pos.avg <- data.sub[ ,list(N=.N, Pred=mean(Pred)),by=\"Position\"]\n  if (mean.adj) {\n    data.sub <- fn.mean.adj(data.sub)\n    data.pos.avg <- merge(\n      data.pos.avg, data.sub[ ,list(Pred=mean(Pred)),by=\"Position\"],\n      by=\"Position\", suffixes=c(\"Raw\", \"Adj\")\n    )\n    data.pos.avg[, Mult := round(PredAdj/PredRaw, digits=3)]\n  }\n  print(data.pos.avg)\n  data.sub[, Pred := fn.round.pred(Pred)]\n  setnames(data.sub, \"Pred\",\"IsClick\")\n  data.sub[, IsClick := pmax(0.0, pmin(1.0, IsClick))]\n  write.csv(data.sub[, list(ID, IsClick)],\n            file = xzfile(paste0(fn.submission.file(file.name), \".7z\")), \n            row.names = F, quote = F)\n  toc()\n  invisible(data.sub)\n}\n\n#############################################################\n# adjust mean of predictions\n#############################################################\nfn.mean.adj <- function(data.pred) {\n  cols.add <- setdiff(c(\"Position\"), colnames(data.pred))\n  if (length(cols.add) > 0) {\n    data.pred <- merge(\n      data.pred,\n      data.all.search.small[, c(\"ID\", cols.add), with=F],\n      by=\"ID\")\n  }\n  data.search.avg <- data.table(\n    Position = c(1,7),\n    IsClickAvg = c(0.011927465*0.975, 0.006011063*0.93)\n  )\n  data.pred.avg <- data.pred[,list(PredAvg=mean(Pred)),\n                             c(\"Position\")]\n  data.pred.avg <- merge(\n    data.search.avg,\n    data.pred.avg,\n    by=c(\"Position\"))\n    \n  data.pred <- merge(\n      data.pred,\n      data.pred.avg,\n      by=c(\"Position\"))\n  \n  data.pred[, Pred:=Pred/PredAvg*IsClickAvg]\n  for (col.nam in cols.add) {\n    data.pred[, col.nam := NULL, with=F]\n  }\n  data.pred[, IsClickAvg := NULL]\n  data.pred[, PredAvg := NULL]\n  data.pred[order(ID)]\n}\n\n##############################################################\n## find mode\n##############################################################\nfn.mode <- function(x) {\n  ux <- unique(x)\n  ux[which.max(tabulate(match(x, ux)))]\n}\n\n##############################################################\n## parse dates\n##############################################################\nfn.parse.date <- function(date.all, ...) {\n  date.all.unique <- unique(date.all)\n  date.parsed <- as.POSIXct(date.all.unique, ...)\n  date.map <- data.table(\n    val=date.all.unique, date=date.parsed,\n    key=\"val\")\n  date.map[J(date.all)]$date\n}\n\n##############################################################\n## calibrate probabilities\n##############################################################\nfn.calibrate.prob <- function(data.pred) {\n  data.pred <- merge(data.pred[, list(ID, Pred)], \n                     data.all.search.small[, list(ID, IsClick, Position)],\n                     by=\"ID\")\n  ix.has.click <- !is.na(data.pred$IsClick) \n  pos.all <- sort(unique(data.pred$Position))\n  suppressMessages(library(\"rPython\"))\n  python.load(\"../avito-context-click-py/util_rpython.py\")\n  \n  data.pred.calib.all <- NULL\n  # for (pos.cur in pos.all) {\n    # ix.pos <- data.pred$Position == pos.cur\n    ix.pos <- data.pred$Position %in% pos.all\n    ix.val <- ix.has.click & ix.pos\n    ix.test <- !ix.has.click & ix.pos\n    data.pred.calib <- python.call('calibrate_probs',\n                                   y_val=data.pred[ix.val]$IsClick,\n                                   prob_val=data.pred[ix.val]$Pred,\n                                   prob_test=data.pred[ix.test]$Pred)\n    data.pred.calib.all <- rbind(\n      data.pred.calib.all, \n      data.table(\n        ID = c(data.pred[ix.val]$ID, data.pred[ix.test]$ID),\n        Pred = c(data.pred.calib$val, data.pred.calib$test)\n      ))\n  # }\n  # fn.mean.adj(data.pred.calib.all[order(ID)])\n  data.pred.calib.all[order(ID)]\n}\n\n##############################################################\n## calibrate probabilities - worker version\n##############################################################\nfn.calibrate.prob.wk <- function(data.pred) {\n  fn.register.wk(1)\n  data.pred.calib <- foreach(\n    tmp=1, .combine=rbind) %dopar% {\n      fn.init.worker()\n      fn.calibrate.prob(data.pred)\n    }\n  fn.kill.wk()\n  data.pred.calib\n}\n\n##############################################################\n## write csv using chunks\n##############################################################\nfn.write.csv.chunk <- function (data, subset=1:nrow(data), \n                                file, \n                                row.names = F, \n                                na = \"\", \n                                compress=T,\n                                ...)  {\n\n\tif (is.logical(subset)) {\n\t\tsubset <- which(subset)\n\t}\n\t\n  append <- F\n\tfor (ix.ch in chunk(from=1,to=length(subset),by=5000000, maxindex=length(subset))) {\n\t\tix = subset[ix.ch[1]:ix.ch[2]]\n\t\twrite.csv(\n        data[ix,],\n        file=file,\n        append=append,\n        row.names=row.names,\n        na=na,\n        ...\n      )\n\t\tappend=T\n\t}\n  if (compress) {\n    system(paste(\"pigz -f\", file))\n  }\n}\n\n##############################################################\n## unloads SOAR objects from emory\n##############################################################\nfn.soar.unload <- function (..., list = character(0), lib = Sys.getenv(\"R_LOCAL_CACHE\", \n    unset = \".R_Cache\"), lib.loc = Sys.getenv(\"R_LOCAL_LIB_LOC\", \n    unset = \".\")) \n{\n  .enc  <- local({\n  \n    bad <- c(\" \", \"<\", \">\", \":\", \"\\\"\", \"/\", \"\\\\\", \"|\", \"?\", \"*\")\n    rpl <- paste(\"@\", 0:9, sep = \"\")\n  \n    regex <- paste(\"(\", paste(LETTERS, collapse = \"|\"), \")\", sep = \"\")\n  \n    function (x) {\n      x <- gsub(\"@\", \"\\t\", x, fixed = TRUE)\n      for (i in seq(along = bad))\n        x <- gsub(bad[i], rpl[i], x, fixed = TRUE)\n      x <- gsub(regex, \"@\\\\1\", x)\n      x <- gsub(\"\\t\", \"@@\", x, fixed = TRUE)\n      paste(x, \"@.RData\", sep = \"\")\n    }\n  })\n  \n  .dec  <- local({\n  \n    bad <- c(\" \", \"<\", \">\", \":\", \"\\\"\", \"/\", \"\\\\\", \"|\", \"?\", \"*\")\n    rpl <- paste(\"@\", 0:9, sep = \"\")\n  \n    regex <- paste(\"@(\", paste(LETTERS, collapse = \"|\"), \")\", sep = \"\")\n  \n    function (x) {\n      x <- gsub(\"@@\", \"\\t\", x, fixed = TRUE)\n      x <- sub(\"@\\\\.RData$\", \"\", x)\n      x <- sub(\"\\\\.RData$\", \"\", x)\n      x <- gsub(regex, \"\\\\1\", x)\n      for (i in seq(along = bad))\n        x <- gsub(rpl[i], bad[i], x, fixed = TRUE)\n      gsub(\"\\t\", \"@\", x, fixed = TRUE)\n    }\n  })\n  \n  .mostFiles <- function(path)\n    setdiff(dir(path, all.files = TRUE), c(\".\", \"..\"))\n  \n  .pathAttributes <- function () {\n    s <- search()\n    paths <- lapply(1:length(s),\n                    function(i) attr(as.environment(i), \"path\"))\n    paths[[length(s)]] <- system.file()\n    m <- sapply(paths, is.null)\n    paths[m] <- s[m]\n    unlist(paths)\n  }\n  \n  .attach <- function(directory, pos = 2,\n                      warn = !file.exists(directory),\n                      readonly) {\n    env <- attach(NULL, pos, basename(directory))\n    attr(env, \"path\") <- directory\n    attr(env, \"readonly\") <- readonly\n    if (file.exists(directory)) {\n      fils <- .mostFiles(directory)\n      objs <- .dec(fils)\n      fils <- file.path(directory, fils)\n      for(i in seq(along = objs))\n        eval(substitute(delayedAssign(OBJECT, {\n          load(file = FILE)\n          get(OBJECT)\n        }), list(OBJECT = objs[i], FILE = fils[i])),\n             envir = env)\n    } else if (warn)\n      warning(paste(directory,\n                    \"does not currently exist. \",\n                    \"A call to 'Store' will create it.\"),\n              call. = FALSE)\n  }\n  \n  .makeClone <- function(Name, Which) {\n    dsn <- deparse(substitute(Name))\n    dsw <- deparse(substitute(Which))\n    f <- function(...) {}\n    body(f) <- substitute({\n      Call <- match.call()\n      Call[[1]] <- quote(SOAR::NAME)\n      if(is.null(Call[[\"lib\"]]))\n        Call[[\"lib\"]] <- Sys.getenv(LIB, unset = WHICH)\n      if(is.null(Call[[\"lib.loc\"]]))\n        Call[[\"lib.loc\"]] <- Sys.getenv(LIB_LOC, unset = path.expand(\"~\"))\n      eval.parent(Call)\n    }, list(NAME = as.name(dsn),\n            WHICH = paste(\".R\", dsw, sep = \"_\"),\n            LIB = paste(\"R_CENTRAL\", toupper(dsw), sep = \"_\"),\n            LIB_LOC = \"R_CENTRAL_LIB_LOC\"))\n    f\n  }\n  \n    if (class((.x <- substitute(lib))) == \"name\") \n        lib <- deparse(.x)\n    else lib <- lib\n    if (!(file.exists(lib.loc) && file.info(lib.loc)$isdir)) \n        stop(lib.loc, \" is not an existing directory.\", call. = FALSE, \n            domain = NA)\n    path <- file.path(lib.loc, lib)\n    if (file.exists(path) && !file.info(path)$isdir) \n        stop(path, \" exists but is not a directory!\", call. = FALSE, \n            domain = NA)\n    if (m <- match(path, .pathAttributes(), nomatch = FALSE)) {\n        e <- as.environment(m[1])\n        if (!is.null(n <- attr(e, \"readonly\")) && n) \n            stop(path, \" is attached as read only!\", call. = FALSE, \n                domain = NA)\n    }\n    nam <- list\n    if (!is.null(m <- match.call(expand.dots = FALSE)$...)) \n        nam <- c(nam, sapply(m, function(x) switch(class(x), \n            name = deparse(x), call = {\n                o <- eval(x, envir = parent.frame(n = 4))\n                if (!is.character(o)) stop(\"non-character name!\", \n                  call. = FALSE, domain = NA)\n                o\n            }, character = x, stop(\"garbled call to 'Store'\", \n                call. = FALSE, domain = NA))))\n    if (length(nam) == 0) \n        return()\n    nam <- drop(sort(unique(nam)))\n    for (n in nam) {\n        no <- !exists(n, inherits = FALSE, envir = parent.frame())\n        comm <- if (no) \n            substitute({\n                assign(N, get(N))\n                rm(list = N)\n            }, list(N = n))\n        eval.parent(comm)\n    }\n    pos <- if (any(m <- (.pathAttributes() == path))) {\n        m <- which(m)[1]\n        detach(pos = m)\n        m\n    }\n    else 2\n    .attach(path, pos = pos, warn = FALSE, readonly = FALSE)\n    o <- intersect(eval.parent(quote(objects(all.names = TRUE))), \n                   nam)\n    if (length(o) > 0) \n      eval.parent(substitute(remove(list = O), list(O = o)))\n    \n    invisible(gc())\n}\n\n##############################################################\n## load ensemble data\n##############################################################\nfn.load.ens <- function(ens.cols, transf=identity,\n                        print.err = T) {\n  \n  data.ens.pred <- NULL\n  err.all <- NULL\n  for (pred.nam in unique(ens.cols)) {\n    pred.nam.orig <- pred.nam\n    data.cur <- get(pred.nam)[,list(ID, Pred)]\n    data.cur <- transf(data.cur)\n    if (is.null(data.ens.pred)) {\n      data.ens.pred <- data.table(data.cur)\n    } else {\n      data.ens.pred <- merge(data.ens.pred, data.cur, by=\"ID\")\n    }\n    pred.nam <- gsub(\"^data\\\\.\", \"\", pred.nam)\n    pred.nam <- gsub(\"\\\\.pred$\", \"\", pred.nam)\n    if (print.err) {\n      df.err <- fn.print.err(data.ens.pred, do.print = F)\n      err.cur <- df.err$Loss\n      names(err.cur) <- pred.nam\n      err.all <- c(err.all, err.cur)\n    }\n    setnames(data.ens.pred, \"Pred\", pred.nam)\n    fn.soar.unload(list=pred.nam.orig)\n  }\n  if (!is.null(err.all)) {\n    print(err.all)\n  }\n  data.ens.pred[order(ID)]\n}\n\n##############################################################\n## print correlations\n##############################################################\nfn.ens.cor <- function(data.ens.pred, first.col = NULL, do.print=T) {\n  data.ens.cols <- setdiff(colnames(data.ens.pred), c(\"ID\"))\n  data.ens.cor <- data.frame(t(combn(length(data.ens.cols), 2)))\n  colnames(data.ens.cor) <- c(\"col1\", \"col2\")\n  data.ens.cor$linear_cor <- NA_real_ \n  data.ens.cor$mean_diff <- NA_real_ \n  # data.ens.cor$mean_abs_diff <- NA_real_ \n  data.ens.cor$sd <- NA_real_ \n  data.ens.cor$col1 <- data.ens.cols[data.ens.cor$col1]\n  data.ens.cor$col2 <- data.ens.cols[data.ens.cor$col2]\n  if (!is.null(first.col)) {\n    fn.sel.col <- function(cols) {\n      as.logical(apply(sapply(first.col,  function(x) cols %like% x), 1, max))\n    }\n    data.ens.cor <- data.ens.cor[\n      fn.sel.col(data.ens.cor$col1) | fn.sel.col(data.ens.cor$col2),]\n  }\n  for (ix in 1:nrow(data.ens.cor)) {\n    p1 <- data.ens.pred[[data.ens.cor$col1[ix]]]\n    p2 <- data.ens.pred[[data.ens.cor$col2[ix]]]\n    pred.ix <- which((p1 != 0 | p2 != 0) & data.ens.pred$ID > 0)\n    p1 <- p1[pred.ix]\n    p2 <- p2[pred.ix]\n    data.ens.cor$linear_cor[ix] <- cor(p1, p2)\n    data.ens.cor$mean_diff[ix] <- mean(p1 - p2)\n    # data.ens.cor$mean_abs_diff[ix] <- mean(abs(p1 - p2))\n    data.ens.cor$sd[ix] <- sd(p1 - p2)\n  }\n  if (do.print) {\n    print(data.ens.cor)\n  }\n  invisible(data.ens.cor)\n}\n\n##############################################################\n## cross val folds\n##############################################################\nfn.cv.ens.folds <- function(seed = 34234) {\n  \n  ids <- data.all.search.small[SearchType==\"val\", list(ID, SearchID)]\n  ids.search <- sort(unique(ids$SearchID))\n  n <- length(ids.search)\n  suppressMessages(library(\"cvTools\"))\n  \n  if (!is.null(seed)) {\n    set.seed(seed)\n  }\n  data.cv.folds <- cvFolds(n, K = 2, type = \"random\")\n  if (!is.null(seed)) {\n    set.seed(Sys.time())\n  }\n  \n  data.cv.folds <- list(\n    n = data.cv.folds$n,\n    K = data.cv.folds$K,\n    which = data.cv.folds$which[data.cv.folds$subsets][1:n],\n    ids = ids,\n    ids.search = ids.search\n  )\n  data.cv.folds\n}\n\n##############################################################\n## cross val selection\n##############################################################\nfn.cv.which <- function(data.all, k, type, cv.data=data.cv.ens) {\n  sel.ids <- cv.data$ids.search[!cv.data$which %in% k]\n  sel.ids <- cv.data$ids[SearchID %in% sel.ids]$ID\n  ix <- data.all$ID %in% sel.ids\n  if (type == \"tr\") {\n    return (which(ix))\n  } else {\n    return (which(!ix))\n  }\n}\n\n#############################################################\n# optmin logloss regression - arithmethic average\n#############################################################\nfn.opt.lr.pred <- function(pars, x) {\n  if (is.list(pars) && \"par\" %in% names(pars)) {\n   pars <- pars$par \n  }\n  if (!is.matrix(x)) {\n    x <- as.matrix(x)\n  }\n  bias <- 0\n  if (ncol(x) != length(pars)) {\n    bias <- pars[1]\n    pars <- pars[-1]\n  }\n  (x %*% pars)[,1] + bias\n}\n\n#############################################################\n# optmin logloss regression - geometric average\n#############################################################\nfn.opt.gm.pred <- function(pars, x) {\n\n  if (is.list(pars) && \"par\" %in% names(pars)) {\n    pars <- pars$par \n  }\n  if (!is.matrix(x)) {\n    x <- as.matrix(x)\n  }\n  bias <- 0\n  if (ncol(x) != length(pars)) {\n    bias <- pars[1]\n    pars <- pars[-1]\n  }\n  rowProds(sapply(1:ncol(x), function (i) x[,i]^pars[i])) + bias\n}\n\n##############################################################\n## optmizes log loss\n##############################################################\nfn.opt.ll.train <- function(x, y, pars=rep(1/ncol(x),ncol(x)), bias=NA, \n                            fn.opt.cfg) {\n  if (!is.matrix(x)) {\n    x <- as.matrix(x)\n  }\n  if (!is.na(bias)) {\n    pars <- c(bias, pars)\n  }\n  \n  if (is.null(fn.opt.cfg$fn.opt)) {\n    fn.opt <- function(pars) fn.log.loss(y, fn.opt.cfg$fn.pred(pars, x))\n  } else {\n    fn.opt <- function(pars) fn.opt.cfg$fn.opt(x, y, pars)\n  }\n  \n  res <- optim(pars, control = list(trace = T), fn.opt)\n  if (!is.na(bias)) {\n    names(res$par) <- c(\"bias\", colnames(x))\n    res$par[-1] <- res$par[-1]/sum(res$par[-1])\n  } else {\n    names(res$par) <- colnames(x)\n    res$par <- res$par/sum(res$par)\n  }\n  \n  \n  res$fn.pred <- fn.opt.cfg$fn.pred\n  \n  res\n}\n\n  \n##############################################################\n## calculates prob counts\n##############################################################\nfn.build.prob.stats <- function(\n  data.all,\n  cols.stats,\n  ids.tr,\n  ids.test,\n  use.slide\n  ) {\n  \n  data.all.stats <- data.all[\n    get('ID') %in% unique(c(ids.tr, ids.test)),\n    c(\"ID\", \"SearchDate\", \"SearchID\", \"IsClick\", cols.stats),\n    with=F]\n  setkeyv(data.all.stats, c(\"SearchDate\", \"SearchID\"))\n  data.all.stats[ID %in% ids.test, IsClick := NA_real_]\n  \n  if (use.slide) {\n    data.all.stats <- data.all.stats[\n      ,list(\n        ID = ID,\n        pos = cumsum(IsClick %in% c(1)),\n        n = cumsum(!is.na(IsClick))\n      ), by = cols.stats][ID %in% ids.test]\n  } else {\n    data.all.stats <- merge(\n      data.all.stats[get('ID') %in% ids.test, c(\"ID\", cols.stats), with=F],\n      data.all.stats[\n        ID %in% ids.tr,\n        list(\n          pos = sum(IsClick, na.rm=T),\n          n = sum(!is.na(IsClick))\n        ), by = cols.stats],\n      by=cols.stats, all.x=T\n    )\n    data.all.stats[is.na(pos), pos := 0]\n    data.all.stats[is.na(n), n := 0]\n  }\n  \n  invisible(gc())\n  for (col.nam in cols.stats) {\n    data.all.stats[, col.nam := NULL, with=F]\n  }\n  setkey(data.all.stats, ID)\n  data.all.stats\n}\n\n##############################################################\n## calculates prob counts\n##############################################################\nfn.build.prob <- function(\n  cols.prob.list, data.all=data.all.lr.small,\n  k.opt=round(10^seq(1, 2.5, 0.5)),\n  k.max=500\n) {\n  \n  data.prob.all <- data.all.out.small[order(ID), list(ID, IsClick)]\n  data.click.mean <- mean(data.prob.all$IsClick, na.rm=T)\n  for (cols.stats in cols.prob.list) {\n    col.target <- paste(c(\"Prob\", cols.stats), collapse=\"\")\n    cat(\"\\nCalculating\", col.target, \"from\", \n        paste(cols.stats, collapse=\" \"), \": \")\n    cat(\"tr, \")\n    data.prob.stats.tr <- fn.build.prob.stats(\n      data.all = data.all,\n      cols.stats = cols.stats,\n      ids.tr = data.all$ID[as.character(data.all$SearchType) %chin% \"hist\"],\n      ids.test = data.all$ID[as.character(data.all$SearchType) %chin% \"tr\"],\n      use.slide = F\n    )\n    invisible(gc())\n    cat(\"val, \")\n    data.prob.stats.val <- fn.build.prob.stats(\n      data.all = data.all,\n      cols.stats = cols.stats,\n      ids.tr = data.all$ID[as.character(data.all$SearchType) %chin% c(\"hist\", \"tr\")],\n      ids.test = data.all$ID[as.character(data.all$SearchType) %chin% \"val\"],\n      use.slide = F\n    )\n    invisible(gc())\n    cat(\"test\")\n    data.prob.stats.test <- fn.build.prob.stats(\n      data.all = data.all,\n      cols.stats = cols.stats,\n      ids.tr = data.all$ID[as.character(data.all$SearchType) %chin% c(\"hist\", \"tr\", \"val\")],\n      ids.test = data.all$ID[as.character(data.all$SearchType) %chin% \"test\"],\n      use.slide = F\n    )\n    invisible(gc())\n    cat(\" - done. k fitting started...\\n\")\n    data.prob.stats <- rbind(\n      #data.prob.stats.hist,\n      data.prob.stats.tr, \n      data.prob.stats.val,\n      data.prob.stats.test)\n    setkeyv(data.prob.stats, \"ID\")\n    rm(data.prob.stats.tr, # data.prob.stats.hist, \n       data.prob.stats.val, data.prob.stats.test)\n    invisible(gc())\n    \n    if (!all(data.prob.stats$ID == data.prob.all$ID)) {\n      stop('IDs of instances do not match!')\n    }\n    \n    # data.prob.stats[, w := fn.transf(w)/w]\n    \n    # calculate smoothed averages\n    fn.opt.prob.cal <- function(pos, n, k, avg=data.click.mean)\n        {round((pos + k*avg)/(n+max(c(0, min(c(k.max, k))))), digits=6) }\n    fn.opt.prob.loss <- function(pars) {\n      fn.log.loss(data.prob.all$IsClick, \n                  fn.opt.prob.cal(pos=data.prob.stats$pos,\n                               n=data.prob.stats$n,\n                               k=pars)) \n    }\n    if (is.null(k.opt)) {\n      best.k <- optim(10, control = list(trace = F), fn.opt.prob.loss)\n    } else {\n      k.loss <- sapply(k.opt, fn.opt.prob.loss)\n      k.ix <- which.min(k.loss)\n      best.k <- list(par=k.opt[k.ix], value=k.loss[k.ix])\n    }\n    cat(col.target, 'best k:', best.k$par, ', loss:', best.k$value, '\\n')\n    data.prob.stats[, Pred := fn.opt.prob.cal(pos=pos, n=n, k=best.k$par)]\n    data.prob.all[, col.target := data.prob.stats$Pred, with=F]\n    rm(data.prob.stats)\n    invisible(gc())\n  }\n  data.prob.all[, IsClick := NULL]\n  return (data.prob.all)\n}\n\n##############################################################\n## calculates prob counts\n##############################################################\nfn.build.prob.stats.full <- function(\n  data.all,\n  cols.stats,\n  sign=1\n  ) {\n  \n  data.all.stats <- data.all[\n    , c(\"ID\", \"SearchDate\", \"SearchID\", \"IsClick\", cols.stats), with=F]\n  data.all.stats[, SearchDate := sign*SearchDate]\n  setkey(data.all.stats, SearchDate, SearchID)\n  \n  fn.prev.val <- function(x) c(0, x[-length(x)]) \n  data.all.stats <- data.all.stats[\n    ,list(\n      ID = ID,\n      is_second = SearchID == fn.prev.val(SearchID),\n      cur_pos = as.numeric(IsClick == 1 & !is.na(IsClick)),\n      pos = cumsum(IsClick == 1 & !is.na(IsClick)),\n      cur_n = as.numeric(!is.na(IsClick)),\n      n = cumsum(!is.na(IsClick))\n    ), by = cols.stats]\n  \n  data.all.stats[, pos := pos - cur_pos - is_second*fn.prev.val(cur_pos)]\n  data.all.stats[, n := n - cur_n  - is_second*fn.prev.val(cur_n)]\n  \n  invisible(gc())\n\n  cols.rm <- setdiff(colnames(data.all.stats), c(\"ID\", \"n\", \"pos\"))\n  for (col.nam in cols.rm) {\n    data.all.stats[, col.nam := NULL, with=F]\n  }\n  invisible(gc())\n  setkey(data.all.stats, ID)\n  data.all.stats\n}\n\n##############################################################\n## calculates prob counts\n##############################################################\nfn.build.prob.full <- function(\n  cols.prob.list, data.all=data.all.lr.small,\n  k.opt=c(30, 100),\n  k.max=500\n) {\n  \n  data.prob.all <- data.all.out.full[order(ID), list(ID, IsClick)]\n  fn.soar.unload(data.all.out.full)\n  invisible(gc())\n  \n  for (cols.stats in cols.prob.list) {\n    col.target <- paste(c(\"Prob\", cols.stats), collapse=\"\")\n    cat(\"\\nCalculating\", col.target, \"from\", \n        paste(cols.stats, collapse=\" \"), \": \")\n    cat(\"hist, \")\n    data.prob.stats <- fn.build.prob.stats.full(\n      data.all = data.all,\n      cols.stats = cols.stats\n    )\n    setkey(data.prob.stats, ID)\n    invisible(gc())\n    \n    cat(\"tr, \")\n    data.prob.stats.tr <- fn.build.prob.stats(\n      data.all = data.all,\n      cols.stats = cols.stats,\n      ids.tr = data.all$ID[as.character(data.all$SearchType) %chin% \"hist\"],\n      ids.test = data.all$ID[as.character(data.all$SearchType) %chin% \"tr\"],\n      use.slide = F\n    )\n    setkey(data.prob.stats.tr, ID)\n    tr.ix <- which(data.prob.stats$ID %in% data.prob.stats.tr$ID)\n    if (!all(data.prob.stats$ID[tr.ix] == data.prob.stats.tr$ID)) {\n      stop('Ids dont match')\n    }\n    data.prob.stats[tr.ix, n:= data.prob.stats.tr$n]\n    data.prob.stats[tr.ix, pos:= data.prob.stats.tr$pos]\n    rm(data.prob.stats.tr)\n    invisible(gc())\n    \n    cat(\"val, \")\n    data.prob.stats.val <- fn.build.prob.stats(\n      data.all = data.all,\n      cols.stats = cols.stats,\n      ids.tr = data.all$ID[as.character(data.all$SearchType) %chin% c(\"hist\", \"tr\")],\n      ids.test = data.all$ID[as.character(data.all$SearchType) %chin% \"val\"],\n      use.slide = F\n    )\n    setkey(data.prob.stats.val, ID)\n    val.ix <- which(data.prob.stats$ID %in% data.prob.stats.val$ID)\n    if (!all(data.prob.stats$ID[val.ix] == data.prob.stats.val$ID)) {\n      stop('Ids dont match')\n    }\n    data.prob.stats[val.ix, n:= data.prob.stats.val$n]\n    data.prob.stats[val.ix, pos:= data.prob.stats.val$pos]\n    rm(data.prob.stats.val)\n    invisible(gc())\n    \n    cat(\"test\")\n    data.prob.stats.test <- fn.build.prob.stats(\n      data.all = data.all,\n      cols.stats = cols.stats,\n      ids.tr = data.all$ID[as.character(data.all$SearchType) %chin% c(\"hist\", \"tr\", \"val\")],\n      ids.test = data.all$ID[as.character(data.all$SearchType) %chin% \"test\"],\n      use.slide = F\n    )\n    setkey(data.prob.stats.test, ID)\n    test.ix <- which(data.prob.stats$ID %in% data.prob.stats.test$ID)\n    if (!all(data.prob.stats$ID[test.ix] == data.prob.stats.test$ID)) {\n      stop('Ids dont match')\n    }\n    data.prob.stats[test.ix, n:= data.prob.stats.test$n]\n    data.prob.stats[test.ix, pos:= data.prob.stats.test$pos]\n    rm(data.prob.stats.test)\n    invisible(gc())\n    \n    cat(\" - done. k fitting started...\\n\")\n    setkeyv(data.prob.stats, \"ID\")\n    fn.check.id(data.prob.stats, data.prob.all)\n    \n    all.ix <- sort(unique(c(tr.ix, val.ix)))\n    rm(tr.ix, val.ix, test.ix)\n    \n    data.click.mean <- mean(data.prob.all$IsClick[all.ix], na.rm=T)\n    # calculate smoothed averages\n    fn.opt.prob.cal <- function(pos, n, k, avg=data.click.mean)\n        {round((pos + k*avg)/(n+max(c(0, min(c(k.max, k))))), digits=6)}\n    fn.opt.prob.loss <- function(pars) {\n      fn.log.loss(data.prob.all$IsClick[all.ix], \n                  fn.opt.prob.cal(pos=data.prob.stats$pos[all.ix],\n                               n=data.prob.stats$n[all.ix],\n                               k=pars)) \n    }\n    if (is.null(k.opt)) {\n      best.k <- optim(10, control = list(trace = F), fn.opt.prob.loss)\n    } else {\n      k.loss <- sapply(k.opt, fn.opt.prob.loss)\n      k.ix <- which.min(k.loss)\n      best.k <- list(par=k.opt[k.ix], value=k.loss[k.ix])\n    }\n    cat(col.target, 'best k:', best.k$par, ', loss:', best.k$value, '\\n')\n    data.prob.stats[, Pred := fn.opt.prob.cal(pos=pos, n=n, k=best.k$par)]\n    data.prob.all[, col.target := data.prob.stats$Pred, with=F]\n    rm(data.prob.stats)\n    invisible(gc())\n  }\n  invisible(gc())\n  data.prob.all[, IsClick := NULL]\n  return (data.prob.all)\n}\n\n\n##############################################################\n## builds list nway interaction\n##############################################################\nfn.build.interaction <- function(cols.in, ...) {\n  interact.list <- list(...)\n  list.res <- list()\n  for (itrct in interact.list) {\n    grid.params <- list()\n    for (col.patt in sort(itrct)) {\n      grid.params[[length(grid.params)+1]] <- sort(cols.in[grepl(col.patt, cols.in)])\n    }\n    grid.params <- unique(expand.grid(grid.params, stringsAsFactors = F))\n    ix <- apply(grid.params, 1, function(x) !any(duplicated(x)))\n    grid.params <- grid.params[ix,]\n    ix <- !duplicated(apply(grid.params, 1, \n                            function(x) paste(sort(x), collapse=\" - \")))\n    grid.params <- grid.params[ix,]\n    for (r in 1:nrow(grid.params)) {\n      list.res[[length(list.res)+1]] <- as.character(grid.params[r,])\n    }\n  }\n  list.res\n}\n\n##############################################################\n## creates xgb matrix\n##############################################################\nfn.xgb.matrix <- function(data, subset, col.in, missing = -1) {\n  suppressMessages(library(\"xgboost\"))\n  label <- data$IsClick[subset]\n  if (any(is.na(label))) {\n    xgb.DMatrix(\n      data = as.matrix(data[subset, cols.in, with=F]), \n      missing = missing)\n  } else {\n    xgb.DMatrix(\n      data = as.matrix(data[subset, cols.in, with=F]), \n      label = label,\n      missing = missing)\n  }\n}\n\n##############################################################\n## checks search ids\n##############################################################\nfn.check.searchid <- function(...) {\n  val.last <- NULL\n  for (val.cur in list(...)) {\n    if (nrow(val.cur) != 112159462) {\n      stop('data doesnt have 112159462 rows')\n    }\n    if ( is.unsorted(val.cur$SearchID, strictly=T)) {\n      stop('SearchID not sorted')\n    }\n    if (!is.null(val.last)) {\n      if (!all(val.last$SearchID == val.cur$SearchID)) {\n        stop('number or rows doesnt match')\n      }\n    }\n    val.last <- val.cur\n  }\n}\n\n##############################################################\n## checks ids\n##############################################################\nfn.check.id <- function(...) {\n  val.last <- NULL\n  for (val.cur in list(...)) {\n    if (nrow(val.cur) != 197974096) {\n      stop('data doesnt have 197974096 rows')\n    }\n    if ( is.unsorted(val.cur$ID)) {\n      stop('ID not sorted')\n    }\n    if (!is.null(val.last)) {\n      if (!all(val.last$ID == val.cur$ID)) {\n        stop('number or rows doesnt match')\n      }\n    }\n    val.last <- val.cur\n  }\n}",
    "created" : 1439617104198.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "181909161",
    "id" : "8764819D",
    "lastKnownWriteTime" : 1439613775,
    "path" : "~/Documents/eclipse/AvitoContext2015/final_model/avito-context-click-r/_fn.base.R",
    "project_path" : "_fn.base.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}